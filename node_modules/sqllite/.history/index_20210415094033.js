function encodeUTF8(s) {
	var i, r = [],
		c, x;
	for (i = 0; i < s.length; i++)
		if ((c = s.charCodeAt(i)) < 0x80) r.push(c);
		else if (c < 0x800) r.push(0xC0 + (c >> 6 & 0x1F), 0x80 + (c & 0x3F));
		else {
			if ((x = c ^ 0xD800) >> 10 == 0) //对四字节UTF-16转换为Unicode
				c = (x << 10) + (s.charCodeAt(++i) ^ 0xDC00) + 0x10000,
					r.push(0xF0 + (c >> 18 & 0x7), 0x80 + (c >> 12 & 0x3F));
			else r.push(0xE0 + (c >> 12 & 0xF));
			r.push(0x80 + (c >> 6 & 0x3F), 0x80 + (c & 0x3F));
		};
	return r;
}

// 字符串加密成 hex 字符串
function sha1(s) {
	var data = new Uint8Array(encodeUTF8(s))
	var i, j, t;
	var l = ((data.length + 8) >>> 6 << 4) + 16,
		s = new Uint8Array(l << 2);
	s.set(new Uint8Array(data.buffer)), s = new Uint32Array(s.buffer);
	for (t = new DataView(s.buffer), i = 0; i < l; i++) s[i] = t.getUint32(i << 2);
	s[data.length >> 2] |= 0x80 << (24 - (data.length & 3) * 8);
	s[l - 1] = data.length << 3;
	var w = [],
		f = [
			function () {
				return m[1] & m[2] | ~m[1] & m[3];
			},
			function () {
				return m[1] ^ m[2] ^ m[3];
			},
			function () {
				return m[1] & m[2] | m[1] & m[3] | m[2] & m[3];
			},
			function () {
				return m[1] ^ m[2] ^ m[3];
			}
		],
		rol = function (n, c) {
			return n << c | n >>> (32 - c);
		},
		k = [1518500249, 1859775393, -1894007588, -899497514],
		m = [1732584193, -271733879, null, null, -1009589776];
	m[2] = ~m[0], m[3] = ~m[1];
	for (i = 0; i < s.length; i += 16) {
		var o = m.slice(0);
		for (j = 0; j < 80; j++)
			w[j] = j < 16 ? s[i + j] : rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1),
				t = rol(m[0], 5) + f[j / 20 | 0]() + m[4] + w[j] + k[j / 20 | 0] | 0,
				m[1] = rol(m[1], 30), m.pop(), m.unshift(t);
		for (j = 0; j < 5; j++) m[j] = m[j] + o[j] | 0;
	};
	t = new DataView(new Uint32Array(m).buffer);
	for (var i = 0; i < 5; i++) m[i] = t.getUint32(i << 2);

	var hex = Array.prototype.map.call(new Uint8Array(new Uint32Array(m).buffer), function (e) {
		return (e < 16 ? "0" : "") + e.toString(16);
	}).join("");
	return hex;
}

function handleSize(limit) {
	var size = "";
	if (limit < 0.1 * 1024) { //小于0.1KB，则转化成B
		size = limit.toFixed(2) + "B"
	} else if (limit < 0.1 * 1024 * 1024) { //小于0.1MB，则转化成KB
		size = (limit / 1024).toFixed(2) + "KB"
	} else if (limit < 0.1 * 1024 * 1024 * 1024) { //小于0.1GB，则转化成MB
		size = (limit / (1024 * 1024)).toFixed(2) + "MB"
	} else { //其他转化成GB
		size = (limit / (1024 * 1024 * 1024)).toFixed(2) + "GB"
	}
	var sizeStr = size + ""; //转成字符串
	var index = sizeStr.indexOf("."); //获取小数点处的索引
	var dou = sizeStr.substr(index + 1, 2) //获取小数点后两位的值
	if (dou == "00") { //判断后两位是否为00，如果是则删除00                
		return sizeStr.substring(0, index) + sizeStr.substr(index + 3, 2)
	}
	return size;
}

function compare() {
	return function (a, b) {
		var value1 = a.stats.lastModifiedTime;
		var value2 = b.stats.lastModifiedTime;
		return value1 - value2;
	}
}
class SqlLite {
	constructor(dataBase, platform) {
		if (platform === 'mp-wexin' || platform === 'app') {
			this.deviceId = wx.getSystemInfoSync().deviceId
		} else {
			this.deviceId = sha1("666")
			if (localStorage.getItem("indexDbVersion")) {
				this.version = localStorage.getItem("indexDbVersion")
			} else {
				localStorage.setItem("indexDbVersion", 666)
				this.version = 666
			}
		}
		if (!dataBase) {
			throw new Error("dataBase is required");
		}
		if (!platform) {
			throw new Error("platform is required");
		}
		this.dataBase = dataBase
		this.platform = platform
		if (platform === 'mp-wexin') {
			this.FileSystemManager = wx.getFileSystemManager()
			this.path = `${wx.env.USER_DATA_PATH}/${dataBase}_${this.deviceId}`
			this.MPInit()
		} else if (platform === 'app') {
			this.APPInit()
		} else if (platform === 'pc' || platform === 'h5') {
			this.H5Init()
		}
	}

	/* 
	 执行初始化
	 */
	APPInit() {
		const InfoSync = wx.getStorageInfoSync();
		this.size = handleSize(InfoSync.currentSize)
		this.count = handleSize(InfoSync.keys.length)
	}
	H5Init() {
		try {
			let result = window.indexedDB.open(`${this.dataBase}_${this.deviceId}`, Number(this.version))
			result.onsuccess = (event) => {
				this.db = event.target.result;
			};
			result.onupgradeneeded = (event) => {
				if (!event.target.result.objectStoreNames.contains('storage')) {
					this.objectStore = event.target.result.createObjectStore('storage', {
						keyPath: 'hashID'
					});
					this.objectStore.createIndex('data', 'data', {
						unique: false
					});
				}
			}
		} catch (e) {
			throw new Error(e);
		}
	}
	insert(obj) {
		if (!obj.table) {
			obj.fail("Table is required")
			return
		}
		if (!(obj.list instanceof Array)) {
			obj.fail("List must be an array")
			return
		}
		if (!obj.list.length) {
			obj.fail("list length must be greater than 0")
			return
		}
		obj.keyPath = obj.keyPath ? obj.keyPath : 'id'
		obj.success = obj.success ? obj.success : (res) => { }
		obj.fail = obj.fail ? obj.fail : (res) => { }
		if (this.db) {
			if (!this.db.objectStoreNames.contains(obj.table)) {
				this.db.close()
				let result = window.indexedDB.open(`${this.dataBase}_${this.deviceId}`, Number(this.version) + 1)
				localStorage.setItem("indexDbVersion", Number(this.version) + 1)
				result.onsuccess = (event) => {
					this.db = event.target.result;
					let promiseList = []
					for (let item of obj.list) {
						promiseList.push(this.handleBatchInsert(item, obj.table, obj.keyPath))
					}
					Promise.all(promiseList).then((result) => {
						obj.success({ code: 1, msg: "批量插入成功" })             //['成功了', 'success']
					}).catch((error) => {
						obj.fail({ code: 2, msg: "批量插入失败" })
					})
				};
				result.onupgradeneeded = (event) => {
					if (!event.target.result.objectStoreNames.contains(obj.table)) {
						let objectStore = event.target.result.createObjectStore(obj.table, {
							keyPath: 'hashID'
						});
						objectStore.createIndex('hashID', 'hashID', {
							unique: false
						});
						for (let key in obj.list[0]) {
							objectStore.createIndex(key, key, {
								unique: false
							});
						}
					}
				}
			} else {
				let promiseList = []
				for (let item of obj.list) {
					promiseList.push(this.handleBatchInsert(item, obj.table, obj.keyPath))
				}
				Promise.all(promiseList).then((result) => {
					obj.success({ code: 1, msg: "批量插入成功" })             //['成功了', 'success']
				}).catch((error) => {
					obj.fail({ code: 2, msg: "批量插入失败" })
				})
			}
		} else {
			setTimeout(() => {
				this.insert(obj)
			}, 100);
		}

	}
	select(obj) {
		if (!obj.table) {
			obj.fail("Table is required")
			return
		}
		obj.success = obj.success ? obj.success : (res) => { }
		obj.fail = obj.fail ? obj.fail : (res) => { }
		let storage = this.db.transaction([obj.table], 'readonly').objectStore(obj.table)
		let getResult = storage.getAll()
		getResult.onsuccess = (event) => {
			if (event.target.result) {
				if (obj.page && obj.pageSize) {
					if (typeof obj.page == 'number' && typeof obj.pageSize == 'number' && event.target.result.length) {
						let arr = []
						for (let i = (obj.page - 1) * obj.pageSize; i < obj.page * obj.pageSize; i++) {
							if (event.target.result[i]) {
								arr.push(event.target.result[i])
							}
						}
						obj.success({ code: 1, data: arr, msg: "获取列表成功" })
					} else {
						obj.success({ code: 1, data: event.target.result, msg: "获取列表成功" })
					}
				} else {
					obj.success({ code: 1, data: event.target.result, msg: "获取列表成功" })
				}
			} else {
				obj.success({ code: 1, data: [], msg: "获取列表成功" })
			}
		}
	}
	clearTable(obj) {
		if (!obj.table) {
			obj.fail("Table is required")
			return
		}
		obj.success = obj.success ? obj.success : (res) => { }
		obj.fail = obj.fail ? obj.fail : (res) => { }
		let storage = this.db.transaction([obj.table], 'readwrite').objectStore(obj.table)
		let getResult = storage.clear()
		getResult.onsuccess = (event) => {
			obj.success({ code: 1, msg: "清除成功" })
		}
		getResult.onerror = function (event) {
			reject({
				code: 2,
				err: event,
				msg: "清除失败"
			})
		}
	}
	handleBatchInsert(obj, table, keyPath) {
		return new Promise((resolve, reject) => {
			let storage = this.db.transaction([table], 'readwrite').objectStore(table)
			let getResult = storage.get(sha1(JSON.stringify(obj[keyPath])))
			getResult.onsuccess = (event) => {
				if (event.target.result) {
					obj.hashID = sha1(JSON.stringify(obj[keyPath]))
					let result = storage.put(obj);
					result.onsuccess = function (event) {
						resolve({
							code: 1,
							msg: "数据更新成功"
						})
					}
					result.onerror = function (event) {
						reject({
							code: 2,
							msg: "数据更新失败"
						})
					}
				} else {
					obj.hashID = sha1(JSON.stringify(obj[keyPath]))
					let result = storage.add(obj);
					result.onsuccess = function (event) {
						resolve({
							code: 1,
							msg: "数据插入成功"
						})
					}
					result.onerror = function (event) {
						reject({
							code: 2,
							msg: "数据插入失败"
						})
					}
				}
			}
		})
	}
	MPInit() {
		try {
			let limit = 0
			this.FileSystemManager.accessSync(this.path)
			const statSync = this.FileSystemManager.statSync(this.path, true)
			if (statSync instanceof Array) {
				for (let item of statSync) {
					limit += item.stats.size
				}
				this.size = handleSize(limit)
				this.count = statSync.length
			} else {
				this.size = 0
				this.count = 0
			}
		} catch (e) {
			let limit = 0
			this.FileSystemManager.mkdirSync(this.path)
			this.get({
				key: `lock_${this.deviceId}`,
				success: (res => {
					if (!res) {
						let arr = []
						arr.push('/' + sha1(`lock_${this.deviceId}`) + '.txt')
						this.put({
							key: `lock_${this.deviceId}`,
							data: arr
						})
					}
				})
			})
			const statSync = this.FileSystemManager.statSync(this.path, true)
			if (statSync instanceof Array) {
				for (let item of statSync) {
					limit += item.stats.size
				}
				this.size = handleSize(limit)
				this.count = statSync.length
			} else {
				this.size = 0
				this.count = 0
			}
		}
	}
	/* 
	 执行初始化
	 */

	/*
	 执行插入数据
	 */
	async put(obj) {
		if (!obj.key) {
			throw new Error("key is required");
		}
		obj.data = obj.data ? obj.data : ''
		obj.isLock = obj.isLock ? obj.isLock : false
		obj.table = obj.table ? obj.table : 'storage'
		obj.success = obj.success ? obj.success : (res) => { }
		obj.fail = obj.fail ? obj.fail : (res) => { }
		if (this.platform === 'mp-wexin') {
			try {
				const result = await this.handleMPPut(obj.key, obj.data, obj.isLock)
				obj.success(result)
			} catch (e) {
				obj.fail({ code: 2, err: e, msg: "插入失败" })
			}
		} else if (this.platform === 'app') {
			try {
				const result = await this.handleAPPPut(obj.key, obj.data, obj.isLock)
				obj.success(result)
			} catch (e) {
				obj.fail({ code: 2, err: e, msg: "插入失败" })
			}
		} else if (this.platform === 'pc' || this.platform === 'h5') {
			try {
				const result = await this.handleH5Put(obj)
				if (result) {
					obj.success(result)
				}
			} catch (e) {
				obj.fail({ code: 2, err: e, msg: "插入失败" })
			}
		}
	}
	handleH5Put(obj) {
		if (this.db) {
			return new Promise((resolve, reject) => {
				let storage = this.db.transaction([obj.table], 'readwrite').objectStore(obj.table)
				let getResult = storage.get(sha1(JSON.stringify(obj.key)))
				getResult.onsuccess = (event) => {
					if (event.target.result) {
						let result = storage.put({
							hashID: sha1(JSON.stringify(obj.key)),
							data: JSON.stringify(obj.data)
						});
						result.onsuccess = function (event) {
							resolve({
								code: 1,
								msg: "数据更新成功"
							})
						}
						result.onerror = function (event) {
							reject({
								code: 2,
								msg: "数据更新失败"
							})
						}
					} else {
						let result = storage.add({
							hashID: sha1(JSON.stringify(obj.key)),
							data: JSON.stringify(obj.data)
						});
						result.onsuccess = function (event) {
							resolve({
								code: 1,
								msg: "数据插入成功"
							})
						}
						result.onerror = function (event) {
							reject({
								code: 2,
								msg: "数据插入失败"
							})
						}
					}
				}
			})
		} else {
			setTimeout(() => {
				this.put(obj)
			}, 100)
		}
	}
	handleMPPut(key, data, isLock) {
		if (isLock) this.handleMPLock(key)
		return new Promise((resolve, reject) => {
			this.FileSystemManager.writeFile({
				filePath: `${this.path}/${sha1(JSON.stringify(key))}.txt`,
				data: JSON.stringify(data),
				encoding: 'utf-8',
				success: (res => {
					resolve({
						code: 1,
						msg: "数据插入成功"
					})
				}),
				fail: (e => {
					if (e.errMsg === "fail the maximum size of the file storage limit is exceeded") {
						this.handleMPMax(key, data, isLock)
					} else {
						reject({
							code: 2,
							msg: "数据插入失败"
						})
					}
				})
			})
		})
	}
	handleAPPPut(key, data, isLock) {
		return new Promise((resolve, reject) => {
			if (wx.setStorageSync(sha1(key))) wx.removeStorageSync(sha1(key))
			wx.setStorageSync(sha1(key), JSON.stringify(data))
			wx.setStorage({
				key: sha1(key),
				data: JSON.stringify(data),
				success: (res => {
					resolve({
						code: 1,
						msg: "数据插入成功"
					})
				}),
				fail: (e => {
					reject({
						code: 2,
						msg: "数据插入失败"
					})
				})
			})

		})
	}
	handleMPMax(key, data, isLock) {
		if (!key) {
			throw new Error("key is required");
		}
		try {
			this.FileSystemManager.accessSync(this.path)
			const statSync = this.FileSystemManager.statSync(this.path, true)
			statSync.sort(compare())
			let lockList = this.get(`lock_${this.deviceId}`)
			for (let item of statSync) {
				if (lockList.indexOf(item.path) == -1) {
					this.FileSystemManager.unlinkSync(`${this.path}${statSync[0].path}`)
					this.handleMPPut(key, data, isLock)
					break
				}
			}
		} catch (e) {
			throw new Error(e);
		}
	}
	handleMPLock(key) {
		this.get({
			key: `lock_${this.deviceId}`,
			success: (res => {
				if (res.indexOf('/' + sha1(JSON.stringify(key)) + '.txt') == -1) {
					res.push('/' + sha1(JSON.stringify(key)) + '.txt')
					this.handleMPPut(`lock_${this.deviceId}`, res)
				}
			})
		})
	}
	/*
	 执行插入数据
	 */
	/* 执行获取数据 */
	async get(obj) {
		if (!obj.key) {
			throw new Error("key is required");
		}
		obj.objectStore = obj.objectStore ? obj.objectStore : 'storage'
		obj.table = obj.table ? obj.table : 'storage'
		obj.success = obj.success ? obj.success : (res) => { }
		obj.fail = obj.fail ? obj.fail : (res) => { }
		if (this.platform === 'mp-wexin') {
			try {
				const result = await this.handleMPGet(obj.key)
				obj.success({ code: 1, data: result, msg: "获取数据成功" })
			} catch (e) {
				obj.fail({ code: 1, err: e, msg: "获取数据失败" })
			}
		} else if (this.platform === 'app') {
			try {
				const result = await this.handleAPPGet(obj.key)
				obj.success({ code: 1, data: result, msg: "获取数据成功" })
			} catch (e) {
				obj.fail({ code: 1, err: e, msg: "获取数据失败" })
			}
		} else if (this.platform === 'pc' || this.platform === 'h5') {
			try {
				const result = await this.handleH5Get(obj)
				obj.success({ code: 1, data: result, msg: "获取数据成功" })
			} catch (e) {
				obj.fail({ code: 1, err: e, msg: "获取数据失败" })
			}
		}
	}
	handleMPGet(key) {
		try {
			return JSON.parse(this.FileSystemManager.readFileSync(`${this.path}/${sha1(JSON.stringify(key))}.txt`, 'utf-8'))
		} catch (e) {
			return ''
		}
	}
	async handleH5Get(obj) {
		let storage = this.db.transaction([obj.table], 'readonly').objectStore(obj.table)
		let getResult = storage.get(sha1(JSON.stringify(obj.key)))
		return new Promise((resolve, reject) => {
			getResult.onsuccess = (event) => {
				if (event.target.result) {
					if (obj.table == 'storage') {
						resolve(JSON.parse(event.target.result.data))
					} else {
						resolve(event.target.result)
					}
				} else {
					resolve("")
				}
			}
		})
	}
	handleAPPGet(key) {
		return wx.getStorageSync(sha1(key)) ? JSON.parse(wx.getStorageSync(sha1(key))) : ''
	}
	/* 执行获取数据 */

	/* 执行清除数据 */
	async clear(obj) {
		obj.success = obj.success ? obj.success : (res) => { }
		obj.fail = obj.fail ? obj.fail : (res) => { }
		if (this.platform === 'mp-wexin') {
			try {
				const result = await this.handleMPClear()
				obj.success(result)
			} catch (e) {
				obj.fail(e)
			}
		} else if (this.platform === 'app') {
			wx.clearStorageSync()
			obj.success({
				code: 1,
				msg: "清除成功"
			})
		} else if (this.platform === 'pc' || this.platform === 'h5') {
			try {
				const result = await this.handleH5Clear()
				obj.success(result)
			} catch (e) {
				obj.fail(e)
			}
		}

	}
	handleMPClear() {
		return new Promise((resolve, reject) => {
			this.FileSystemManager.rmdir({
				dirPath: this.path,
				recursive: true,
				success: (res => {
					resolve({
						code: 1,
						msg: "清除成功"
					})
				}),
				fail: (err => {
					reject({
						code: 2,
						msg: "清除失败"
					})
				})
			})
		})
	}
	handleH5Clear() {
		return new Promise((resolve, reject) => {
			this.db.close()
			let result = window.indexedDB.deleteDatabase(`${this.dataBase}_${this.deviceId}`)
			result.onsuccess = (res) => {
				resolve({
					code: 1,
					msg: "清除成功"
				})
			}
			result.onerror = (err) => {
				reject({
					code: 2,
					msg: "清除失败"
				})
			}
		})
	}
	/* 执行清除数据 */

	/* 执行单个删除 */
	async remove(obj) {
		if (!obj.key) {
			throw new Error("key is required");
		}
		obj.table = obj.table ? obj.table : 'storage'
		obj.success = obj.success ? obj.success : (res) => { }
		obj.fail = obj.fail ? obj.fail : (res) => { }
		if (this.platform === 'mp-wexin') {
			try {
				const result = await this.handleMPRemove(obj.key)
				obj.success(result)
			} catch (e) {
				obj.fail({ code: 2, msg: '删除失败' })
			}
		} else if (this.platform === 'app') {
			wx.removeStorageSync(sha1(JSON.stringify(key)))
			obj.success({
				code: 1,
				msg: "删除成功"
			})
		} else if (this.platform === 'pc' || this.platform === 'h5') {
			try {
				const result = await this.handleH5Remove(obj)
				obj.success(result)
			} catch (e) {
				obj.fail(e)
			}
		}
	}
	handleMPRemove(key) {
		if (!key) {
			throw new Error("key is required");
		}
		try {
			this.FileSystemManager.unlinkSync(`${this.path}/${sha1(JSON.stringify(key))}.txt`)
			return {
				code: 1,
				msg: "删除成功"
			}
		} catch (e) {
			throw new Error(e);
		}
	}
	handleH5Remove(obj) {
		if (!key) {
			throw new Error("key is required");
		}
		return new Promise((resolve, reject) => {
			let storage = this.db.transaction([obj.table], 'readwrite').objectStore(obj.table)
			let result = storage.delete(sha1(JSON.stringify(obj.key)))
			result.onsuccess = (res) => {
				resolve({
					code: 1,
					msg: "删除成功"
				})
			}
			result.onerror = (res) => {
				reject({
					code: 2,
					msg: "删除失败"
				})
			}
		})
	}
	/* 执行单个删除 */

	/* 添加数据同步 */
	putAsync(key, data, isLock = false) {
		if (!key) {
			throw new Error("key is required");
		}
		if (!data) {
			throw new Error("data is required");
		}
		if (this.platform === 'mp-wexin') {
			try {
				return this.handleMPPutAsync(key, data, isLock)
			} catch (e) {
				return {
					code: 2,
					msg: '数据插入失败'
				}
			}
		} else if (this.platform === 'app') {
			try {
				wx.setStorageSync(sha1(JSON.stringify(key)), JSON.stringify(data))
				return {
					code: 1,
					msg: '数据插入成功'
				}
			} catch (e) {
				return {
					code: 2,
					msg: '数据插入失败'
				}
			}
		}
	}
	handleMPPutAsync(key, data, isLock) {
		if (isLock) this.handleMPLock(key)
		try {
			this.FileSystemManager.writeFileSync(`${this.path}/${sha1(JSON.stringify(key))}.txt`, JSON.stringify(data),
				'utf-8')
			return {
				code: 1,
				msg: '数据插入成功'
			}
		} catch (e) {
			if (e.errMsg === "fail the maximum size of the file storage limit is exceeded") {
				this.handleMPMax(key, data, isLock)
			} else {
				throw new Error('数据插入失败');
			}
		}
	}
	/* 添加数据同步 */

	/* 获取数据同步 */
	getAsync(key) {
		if (!key) {
			throw new Error("key is required");
		}
		if (this.platform === 'mp-wexin') {
			try {
				return JSON.parse(this.FileSystemManager.readFileSync(`${this.path}/${sha1(JSON.stringify(key))}.txt`, 'utf-8'))
			} catch (e) {
				return ''
			}
		} else if (this.platform === 'app') {
			return wx.getStorageSync(sha1(key)) ? JSON.parse(wx.getStorageSync(sha1(key))) : ''
		}
	}
	/* 获取数据同步 */

	/* 清除数据同步 */
	clearAsync() {
		if (this.platform === 'mp-wexin') {
			try {
				this.FileSystemManager.rmdirSync(this.path, true)
				return {
					code: 1,
					msg: '清除成功'
				}
			} catch (e) {
				return {
					code: 2,
					msg: '清除失败'
				}
			}
		} else if (this.platform === 'app') {
			wx.clearStorageSync()
			return {
				code: 1,
				msg: '清除成功'
			}
		}
	}
	/* 清除数据同步 */

	/* 删除数据同步 */
	removeAsync(key) {
		if (!key) {
			throw new Error("key is required");
		}
		if (this.platform === 'mp-wexin') {
			try {
				this.FileSystemManager.unlinkSync(`${this.path}/${sha1(JSON.stringify(key))}.txt`)
				return {
					code: 1,
					msg: "删除成功"
				}
			} catch (e) {
				return {
					code: 2,
					msg: "删除失败"
				}
			}
		} else if (this.platform === 'app') {
			wx.removeStorageSync(sha1(JSON.stringify(key)))
			return {
				code: 1,
				msg: '删除成功'
			}
		}
	}
	/* 删除数据同步 */
}
export default SqlLite
